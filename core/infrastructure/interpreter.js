/*
 * ===========================================
 *  COLORBLOCK INTERPRETER ENGINE
 *  Filename: core/infrastructure/interpreter.js
 *  Version: 1.0.0
 *  By: Chatflare Corporation & Yohan Foundation
 * ===========================================
 *
 *  This interpreter reads and executes JSON-based
 *  programs generated by Colorblock UI or editor.
 *
 *  Features:
 *  ‚úÖ Reads blocks from /blocks/
 *  ‚úÖ Executes loops, commands, and events
 *  ‚úÖ Maintains context (x, y, angle, vars)
 *  ‚úÖ Supports async operations and visual turtle renderer
 */

export class ColorblockInterpreter {
  constructor(options = {}) {
    this.ctx = {
      x: 0,
      y: 0,
      angle: 90,
      pen: false,
      penColor: "#000000",
      vars: {},
      answer: "",
      color: "#000000"
    };

    this.delay = options.delay || 200;
    this.logEnabled = options.logging ?? true;
    this.renderer = options.renderer || null; // turtle renderer (optional)
    this.categories = {};
  }

  log(...msg) {
    if (this.logEnabled) console.log(...msg);
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async loadBlocks() {
    // Load all category files dynamically
    const catRes = await fetch("blocks/categories.json");
    const cats = await catRes.json();

    for (const category of cats.categories) {
      const res = await fetch(category.file);
      const data = await res.json();
      this.categories[category.id] = data.blocks;
      this.log(`üß± Loaded category: ${category.name} (${data.blocks.length} blocks)`);
    }
  }

  getBlockDefinition(id) {
    for (const catId in this.categories) {
      const found = this.categories[catId].find(b => b.id === id);
      if (found) return found;
    }
    return null;
  }

  async runBlock(block) {
    const def = this.getBlockDefinition(block.id);
    if (!def) {
      this.log(`‚ö†Ô∏è Unknown block: ${block.id}`);
      return;
    }

    const value = block.value ?? block.values ?? null;
    const ctx = this.ctx;

    // Evaluate block action safely
    try {
      if (def.type === "command" && def.action) {
        const code = new Function("ctx", "value", "core", def.action);
        await code(ctx, value, this);
      }

      else if (def.type === "loop") {
        const loopFn = new Function("ctx", "block", "core", def.action);
        await loopFn(ctx, block, this);
      }

      else if (def.type === "event") {
        this.log(`üö© Event: ${def.name}`);
      }

      // Visual turtle move
      if (this.renderer && ["move_steps", "turn_right", "turn_left", "go_to_xy"].includes(block.id)) {
        this.renderer.update(this.ctx);
      }
    } catch (err) {
      console.error(`‚ùå Error in block ${block.id}:`, err);
    }

    await this.sleep(this.delay);
  }

  async runBlocks(blocks) {
    for (const block of blocks) {
      await this.runBlock(block);
    }
  }

  async execute(program) {
    this.log("üöÄ Starting Colorblock Program...");
    await this.loadBlocks();

    if (!program.blocks || program.blocks.length === 0) {
      console.warn("‚ö†Ô∏è No blocks to execute.");
      return;
    }

    // Find ‚Äúwhen run started‚Äù
    const startIndex = program.blocks.findIndex(b => b.id === "when_start");
    if (startIndex === -1) {
      this.log("‚ö†Ô∏è No starting event found, running all blocks directly.");
      await this.runBlocks(program.blocks);
    } else {
      const remaining = program.blocks.slice(startIndex + 1);
      await this.runBlocks(remaining);
    }

    this.log("‚úÖ Program complete!");
  }
}
